## < 0. 모르는 용어 정리 >
- Flink Program
    - Data sink
        - 데이터를 최종적으로 보낼 `최종 목적지`를 지정하는 부분.
        - e.g. kafka로 다시 보내거나, DB에 넣거나, Elasticsearh에 넣거나 etc.
    - Dafaflow graph
        - 데이터 싱크가 최종 목적지라면, Dataflow Graph는 그 목적지까지의 `전체 연산 흐름`을 표현한 것.
        - 즉, `execute()`가 호출되기 전까지 정의된 모든 연산(map, filter, key_by 등)의 논리적인 그래프 구조.
        - 사용자가 작성한 연산 코드 흐름을 Flink가 내부적으로 `그래프(DAG) 형태로 변환`하여 저장함.

## < 1. 배치 처리도 라이브 처럼 가능하지 않나? >
- `마이크로배치`, 즉 배치를 매우 작은 단위로 세팅하면 마치 라이브처럼 흐르도록 할 수 있다.
    - `Spark` 또한 이런 방식으로 라이브 스트리밍을 만들 수 있다.
- 단, 결국 배치를 사용하기에 `초저지연`('입력 &rightarrow; 처리 &rightarrow; 반응'의 과정이 굉장히 빠름)을 요구하는 상황에 적합하지 않기에 이런 경우 `완전 라이브 스트리밍인 Flink`가 적합하다.
    - Flink는 `레코드 단위 처리(데이터가 한 건(record) 들어오자마자 처리)`로 완전 라이브 스트리밍이다. 배치처럼 데이터를 일정량 모으지 않는다.
    - e.g. 운전 중 급정거, fps 게임에서 총의 발사, 그리고 몇 가지 실시간 인터페이스 등. 즉각적인 피드백이 필요한 경우가 해당한다.

### 1-1. Spark vs Flink 핵심 비교 요약

| 항목                         | Spark (Structured Streaming)           | Flink (DataStream API)                   |
|------------------------------|----------------------------------------|------------------------------------------|
| 처리 방식                    | 마이크로배치 (Micro-batch)             | 레코드 단위 처리 (Record-by-record)     |
| 실시간성                     | 가깝게 구현 가능 (초 단위 지연)        | 진짜 실시간 (수 밀리초 지연)            |
| 지연 시간                    | 수 초 이상 (기본 설정 기준)            | 수 밀리초 수준 (튜닝 없이도 빠름)       |
| 배치 처리 지원              | 배치/스트리밍 별도 API                | 스트리밍 기반으로 배치도 지원 (통합)    |
| 윈도우 처리                  | 가능 (튜닝 필요, 제약 있음)            | 매우 유연함 (이벤트타임 보정 등 포함)   |
| 상태 기반 연산 (join 등)    | 가능 (외부 저장소 사용)                | 내장 상태 관리 (rocksdb 등)             |
| 스트리밍 철학                | 배치 중심 + 스트리밍 확장               | 스트리밍 중심 + 배치 포용               |
| 초저지연 처리에 적합한가?   | ⚠️ 제한적 (지연 허용 시 가능)          | ✅ 매우 적합 (실시간 판단/반응 가능)     |
| 사용 예시                   | 실시간 로그 적재, 알림, 지표 집계 등     | 실시간 결제 사기탐지, 자율주행 판단 등  |

## 2. Checkpointing 최적화 (비동기, Aligned, Unaligned)
- **비동기 (Asynchronous Checkpointing)**
    - 원래는 Barrier가 모두 도착하고(정렬) 상태를 저장할 때까지 작업이 멈췄다.
    - 그러나 비동기 방식에서는 스냅샷을 메모리에 복사한 후, `저장 과정`은 별도의 스레드에서 비동기로 수행된다.
    - 즉, `저장(I/O)`을 기다리지 않고 작업은 계속 진행된다.
    - 중요한 점은 비동기는 작업 처리를 멈추냐 아니냐가 아니라 `저장`에 걸리는 시간을 고려하지 않는다는 것이다.

- **Aligned Checkpoint**
    - 여러 입력 스트림 중 먼저 barrier가 도착한 스트림은 `멈추고`, 느린 스트림의 barrier를 `기다린다`.
    - `모든 barrier가 도착`하면 해당 시점의 상태를 스냅샷으로 기록한다.
    - 정확한 상태 일관성을 보장하기 위해 반드시 `정렬(barrier alignment)`이 필요하다.
    - ✔️ 이 방식은 `비동기 저장 방식과 함께 사용된다. (정렬 + 비동기 저장)`.

- **Unaligned Checkpoint**
    - 이 방식은 느린 스트림을 기다리지 않고, `가장 먼저 barrier가 도착한 스트림`을 기준으로 `즉시 스냅샷`을 시작한다.
    - 정확한 복구를 위해 각 연산자의 `state`뿐 아니라 `입력 버퍼`까지 `통째로 저장`한다.
    - 흐름이 절대 끊기지 않고 빠르지만, `스냅샷 크기가 커진다`는 단점이 있다.

| 최적화 방법                   | Barrier 정렬 기다림 | 저장 방식                | 작업 흐름 중단        | 스냅샷 크기 | 특징 요약                                      |
|-------------------------|---------------------|---------------------------|------------------------|-------------|-------------------------------------------------|
| **비동기 + Aligned**     | ✅ 필요함              | ✅ 스냅샷 후 비동기 저장    | ⛔ 정렬 중엔 멈출 수 있음  | 작음        | 정확한 시점 정렬 + 저장은 비동기. 기본 구조.         |
| **Unaligned**           | ❌ 안 기다림           | ✅ 비동기 + 버퍼까지 저장 | ❌ 절대 멈추지 않음       | 큼          | 정렬 없이 바로 저장. 흐름 안 끊기지만 용량 커짐.       |
